# 响应式数据与副作用函数
effect 函数的执行会直接或间接影响其他函数的执行，这时我们说 effect 函数产生了副作用
```js
// 全局变量
const obj = { text: 'hello world'};

function effect () {
  document.body.innerText = obj.text;  // 产生副作用
}
```
`obj.text = 'hello vue3'`

副作用函数 effect 会设置 body 元素的 innerText 属性，其值为 `obj.text`，当 obj.text 的值发生变化时，我们希望副作用函数 effect 会重新执行

# 响应式数据的基本实现

- 当副作用函数 effect 执行时，会触发字段 obj.text 的读取操作；
- 当修改 obj.text 的值时，会触发字段 obj.text 的设置操作。
- 
可以使用代理对象 Proxy 来实现
```js
const data = { text: 'hello world' };

const bucket = new Set();
let activeEffect; 

// 使用effect函数来注册副作用函数fn
function effect(fn) {
  activeEffect = fn;  // 记录当前的副作用函数
  fn();
}
effect(() => {
  document.body.innerText = obj.text;
})

setTimeout(() => {
  obj.text = 'hello vue3';
}, 1000)

const obj = new Proxy(data, {
  get(target, key) {
    // 将副作用函数添加到存储副作用函数的桶里
    if(activeEffect) {
      bucket.add(activeEffect);
    }
    return target[key];
  };

  set(target, key, newVal) {
    target[key] = newVal;
    // 把副作用函数从桶里取出来并执行
    bucket.foEach(fn => fn());
    return true // 代表操作成功
  };
})
```
无论操作 obj 的哪个字段都会触发 set 执行，重新执行副作用函数，即使这个副作用函数与这个字段之间不存在副作用关系；

使用一个 Set 数据结构作为存储副作用函数的“桶”。导致我们没有在副作用函数与被操作的目标字段之间建立明确的联系。

# 解决副作用函数与被操作的key之间没有联系的问题
一个副作用函数通常存在三个角色：
- 被操作（读取）的代理对象如 obj；
- 被操作（读取）的字段名如 text；
- 使用 effect 函数注册的副作用函数如 effectFn。

用 target 来表示一个代理对象所代理的原始对象，用 key 来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，那么这三个角色存在如下关系：

    target____
              key____
                     effectFn

![](../imgs/4.png)

使用 WeakMap 代替 Set 作为桶的数据结构, WeakMap 经常用于存储那些只有当 key 所引用的对象存在时（没有被回收）才有价值的信息;

WeakMap 由 target --> Map 构成；
 
Map 由 key --> Set 构成;

Set 中存储 target[key] 对应的副作用函数。 

![](../imgs/5.png)

具体代码如下：
```js
const bucket = new WeakMap();

const obj = new Proxy(data, {
  get(target, key) {
    track(target, key);
    return target[key]
  };
  
  set(target, key, newVal) {
    target[key] = newVal;
    trigger(target, key);
  };
})

function track(target, key) {
  if(!activeEffect) return;
  let depsMap = bucket.get(target);
  if(!depsMap) {
    depsMap = new Map();
    bucket.set(target, depsMap);
  }
  let deps = depsMap.get(key);
  if(!deps) {
    deps = new Set();
    depsMap.set(key, deps);
  }
  deps.add(activeEffect);
}

function trigger(target, key) {
  let depsMap = bucket.get(target);
  if(!depsMap) return;
  let effects = depsMap.get(key);
  effects && effects.forEach(fn => fn());
}
```
